# -*- coding: utf-8 -*-
"""Algoritimos ias.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15NghrZzEf7c-YAgfBfNKQTrlaPykHXsz
"""

# Commented out IPython magic to ensure Python compatibility.
#rede neural
# %reset -f
import pickle
with open('credit.pkl', 'rb') as f:  
  X_credit_treinamento, y_credit_treinamento, X_credit_teste, y_credit_teste = pickle.load(f)
from sklearn.neural_network import MLPClassifier # Neur√¥nios = (3+1)/2 = 2
print(X_credit_treinamento.shape)
rede_neural_credit = MLPClassifier(max_iter=1500, verbose=True, tol=0.0000100,
                                   solver = 'adam', activation = 'relu',
                                   hidden_layer_sizes = (2,2))
rede_neural_credit.fit(X_credit_treinamento, y_credit_treinamento)
previsoes = rede_neural_credit.predict(X_credit_teste)
from sklearn.metrics import accuracy_score, classification_report
print(accuracy_score(y_credit_teste, previsoes))
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(rede_neural_credit)
cm.fit(X_credit_treinamento, y_credit_treinamento)
cm.score(X_credit_teste, y_credit_teste)

# Commented out IPython magic to ensure Python compatibility.
#algoritmo svm
# %reset -f
import pickle
with open('census.pkl', 'rb') as f:  
  X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste = pickle.load(f)
from sklearn.svm import SVC
svm_census = SVC(kernel='rbf', random_state=1, C = 2.0)
svm_census.fit(X_census_treinamento, y_census_treinamento)
previsoes = svm_census.predict(X_census_teste)
from sklearn.metrics import accuracy_score, classification_report
print(accuracy_score(y_census_teste, previsoes))
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(svm_census)
cm.fit(X_census_treinamento, y_census_treinamento)
cm.score(X_census_teste, y_census_teste)

# Commented out IPython magic to ensure Python compatibility.
#bayesiana sem graficos
# %reset -f
import pandas as pd
import numpy as np
np.set_printoptions(threshold=np.inf)
import pickle
with open('credit.pkl', 'rb') as f:
  X_credit_treinamento, y_credit_treinamento, X_credit_teste, y_credit_teste = pickle.load(f)
from sklearn.naive_bayes import GaussianNB
naive_credit_data = GaussianNB()
naive_credit_data.fit(X_credit_treinamento, y_credit_treinamento)
previsoes = naive_credit_data.predict(X_credit_teste)
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
print(accuracy_score(y_credit_teste, previsoes))
print(confusion_matrix(y_credit_teste, previsoes))

# Commented out IPython magic to ensure Python compatibility.
#bayesiana com graficos
# %reset -f
import pandas as pd
import numpy as np
np.set_printoptions(threshold=np.inf)
import pickle
with open('census.pkl', 'rb') as f:
  X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste = pickle.load(f)
from sklearn.naive_bayes import GaussianNB
naive_census = GaussianNB()
naive_census.fit(X_census_treinamento, y_census_treinamento)
previsoes = naive_census.predict(X_census_teste)
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
print(accuracy_score(y_census_teste, previsoes))
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(naive_census)
cm.fit(X_census_treinamento, y_census_treinamento)
cm.score(X_census_teste, y_census_teste)

# Commented out IPython magic to ensure Python compatibility.
#algoritmo KNN
# %reset -f
import pickle
with open('census.pkl', 'rb') as f:  
  X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste = pickle.load(f)
from sklearn.neighbors import KNeighborsClassifier
knn_census = KNeighborsClassifier(n_neighbors=4, metric='minkowski', p = 2)
knn_census.fit(X_census_treinamento, y_census_treinamento)
previsoes = knn_census.predict(X_census_teste)
from sklearn.metrics import accuracy_score, classification_report
accuracy_score(y_census_teste, previsoes)
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(knn_census)
cm.fit(X_census_treinamento, y_census_treinamento)
cm.score(X_census_teste, y_census_teste)